//////////////////////////////////////////////////////////////
//
// Scope and Type checking
//
//////////////////////////////////////////////////////////////
#include <cool-tree.h>
#include <environment.h>
#include <class-tree.h>


///////////////////////////////////////////////
// Check for reserved keywords misuse 
// Basically Self and Self Type
/////////////////////////////////////////////
void class__class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void method_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void attr_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void formal_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void assign_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void static_dispatch_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void dispatch_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void cond_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void loop_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void typcase_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void branch_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void block_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void let_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void plus_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void sub_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void mul_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void divide_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void neg_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void lt_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void eq_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void leq_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void comp_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void int_const_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void bool_const_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void string_const_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void new__class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void isvoid_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void no_expr_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}
void object_class::reserved_symbols_misuse_check(TypeTable& typetable)
{

}

////////////////////////////////////////////////////////////////
// Checks for any undefined type declaration and just replaces it 
// by Object type
////////////////////////////////////////////////////////////////

void class__class::undefined_types_check(TypeTable& typetable)
{

}
void method_class::undefined_types_check(TypeTable& typetable)
{

}
void attr_class::undefined_types_check(TypeTable& typetable)
{

}
void formal_class::undefined_types_check(TypeTable& typetable)
{

}
void assign_class::undefined_types_check(TypeTable& typetable)
{

}
void static_dispatch_class::undefined_types_check(TypeTable& typetable)
{

}
void dispatch_class::undefined_types_check(TypeTable& typetable)
{

}
void cond_class::undefined_types_check(TypeTable& typetable)
{

}
void loop_class::undefined_types_check(TypeTable& typetable)
{

}
void typcase_class::undefined_types_check(TypeTable& typetable)
{

}
void branch_class::undefined_types_check(TypeTable& typetable)
{

}
void block_class::undefined_types_check(TypeTable& typetable)
{

}
void let_class::undefined_types_check(TypeTable& typetable)
{

}
void plus_class::undefined_types_check(TypeTable& typetable)
{

}
void sub_class::undefined_types_check(TypeTable& typetable)
{

}
void mul_class::undefined_types_check(TypeTable& typetable)
{

}
void divide_class::undefined_types_check(TypeTable& typetable)
{

}
void neg_class::undefined_types_check(TypeTable& typetable)
{

}
void lt_class::undefined_types_check(TypeTable& typetable)
{

}
void eq_class::undefined_types_check(TypeTable& typetable)
{

}
void leq_class::undefined_types_check(TypeTable& typetable)
{

}
void comp_class::undefined_types_check(TypeTable& typetable)
{

}
void int_const_class::undefined_types_check(TypeTable& typetable)
{

}
void bool_const_class::undefined_types_check(TypeTable& typetable)
{

}
void string_const_class::undefined_types_check(TypeTable& typetable)
{

}
void new__class::undefined_types_check(TypeTable& typetable)
{

}
void isvoid_class::undefined_types_check(TypeTable& typetable)
{

}
void no_expr_class::undefined_types_check(TypeTable& typetable)
{

}
void object_class::undefined_types_check(TypeTable& typetable)
{

}


///////////////////////////////////////////////////////////////////
// Checks for illegal redefinition of identifiers, features, types 
// and formals
///////////////////////////////////////////////////////////////////
void class__class::redefinition_check(TypeTable& typetable)
{

}
void method_class::redefinition_check(TypeTable& typetable)
{

}
void attr_class::redefinition_check(TypeTable& typetable)
{

}
void formal_class::redefinition_check(TypeTable& typetable)
{

}
void assign_class::redefinition_check(TypeTable& typetable)
{

}
void static_dispatch_class::redefinition_check(TypeTable& typetable)
{

}
void dispatch_class::redefinition_check(TypeTable& typetable)
{

}
void cond_class::redefinition_check(TypeTable& typetable)
{

}
void loop_class::redefinition_check(TypeTable& typetable)
{

}
void typcase_class::redefinition_check(TypeTable& typetable)
{

}
void branch_class::redefinition_check(TypeTable& typetable)
{

}
void block_class::redefinition_check(TypeTable& typetable)
{

}
void let_class::redefinition_check(TypeTable& typetable)
{

}
void plus_class::redefinition_check(TypeTable& typetable)
{

}
void sub_class::redefinition_check(TypeTable& typetable)
{

}
void mul_class::redefinition_check(TypeTable& typetable)
{

}
void divide_class::redefinition_check(TypeTable& typetable)
{

}
void neg_class::redefinition_check(TypeTable& typetable)
{

}
void lt_class::redefinition_check(TypeTable& typetable)
{

}
void eq_class::redefinition_check(TypeTable& typetable)
{

}
void leq_class::redefinition_check(TypeTable& typetable)
{

}
void comp_class::redefinition_check(TypeTable& typetable)
{

}
void int_const_class::redefinition_check(TypeTable& typetable)
{

}
void bool_const_class::redefinition_check(TypeTable& typetable)
{

}
void string_const_class::redefinition_check(TypeTable& typetable)
{

}
void new__class::redefinition_check(TypeTable& typetable)
{

}
void isvoid_class::redefinition_check(TypeTable& typetable)
{

}
void no_expr_class::redefinition_check(TypeTable& typetable)
{

}
void object_class::redefinition_check(TypeTable& typetable)
{

}
